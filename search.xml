<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计模式之单例模式</title>
      <link href="posts/1a4b62fe/"/>
      <url>posts/1a4b62fe/</url>
      
        <content type="html"><![CDATA[<h1 id="单例模式-Singleton-Pattern"><a href="#单例模式-Singleton-Pattern" class="headerlink" title="单例模式(Singleton Pattern)"></a>单例模式(Singleton Pattern)</h1><h2 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h2><p>  单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>  这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li><p>单例类只能有一个实例。</p></li><li><p>单例类必须自己创建自己的唯一实例。</p></li><li><p>单例类必须给所有其他对象提供这一实例。</p></li></ol><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li><p>在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例</p></li><li><p>避免对资源的多重占用</p></li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>没有接口，不能继承，与<strong>单一职责原则</strong>冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>实现单例模式关键点在于<strong>构造函数私有化</strong>，同时又分为饿汉式，懒汉式，枚举等实现方式</p><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>根据具体实现方式又分为静态变量，静态常量和静态代码块等</p><div class="tabs" id="饿汉式"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#饿汉式-1">饿汉式(静态变量)</button></li><li class="tab"><button type="button" data-href="#饿汉式-2">饿汉式(静态常量)</button></li><li class="tab"><button type="button" data-href="#饿汉式-3">饿汉式(静态代码块)</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="饿汉式-1"><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>{</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="饿汉式-2"><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>{</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="饿汉式-3"><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>{</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>该方式的优点是写法简单，并且是线程安全的，没有加锁，执行效率会提高。</p><p>缺点是该对象在类装载载的时候就进行了实例化，没有达到懒加载的目的，容易造成内存浪费。</p><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><div class="tabs" id="懒汉式"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#懒汉式-1">懒汉式(线程不安全)</button></li><li class="tab"><button type="button" data-href="#懒汉式-2">懒汉式(线程安全，同步方法)</button></li><li class="tab"><button type="button" data-href="#懒汉式-3">懒汉式(线程不安全，同步代码块)</button></li><li class="tab"><button type="button" data-href="#懒汉式-4">懒汉式(线程安全，双重检测锁(DCL))</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="懒汉式-1"><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果同时又两个线程调用getInstance方法，同时执行if (instance == null)的判断，由于对方还未进行实例化操作，导致双方都new出了一个对象</span></span><br><span class="line"><span class="comment"> * 多线程环境禁止使用该方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>{}  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>{  </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {  </span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    }  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    }  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="懒汉式-2"><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在方法级别加锁，效率低下</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>{}  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>{  </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {  </span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    }  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    }  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="懒汉式-3"><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多个线程同时通过if (instance == null)，依旧会多次new对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>{</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) {</span><br><span class="line">                instance  = <span class="keyword">new</span> Singleton();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="懒汉式-4"><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双重检测，线程A获得锁之后，即使线程B通过了if (instance == null)，由于获取不到A正在持有的锁，进入等待。</span></span><br><span class="line"><span class="comment"> * 使用volatile保证程序从主内存读取对象，禁止指令重排</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>{</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) {</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {</span><br><span class="line">                    instance  = <span class="keyword">new</span> Singleton();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 与饿汉式同样利用类加载机制来保证初始化实例时只有一个线程，而这种方式是 Singleton 类被装载了，instance 不一定被初始化。</span></span><br><span class="line"><span class="comment"> * 因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>{  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    }  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>{</span><br><span class="line">    }  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>{  </span><br><span class="line">    <span class="keyword">return</span> SingletonHolder.INSTANCE;  </span><br><span class="line">    }  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化, Effective Java 作者 Josh Bloch 提倡的方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>{  </span><br><span class="line">    INSTANCE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h2><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><div class="tabs" id="反序列化破解"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#反序列化破解-1">反序列化破解单例</button></li><li class="tab"><button type="button" data-href="#反序列化破解-2">防止反序列化破解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="反序列化破解-1"><p>Singleton.java</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>{</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>DeserializeSingleton.java</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeserializeSingleton</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        String path = <span class="string">"本地路径"</span>;</span><br><span class="line">        <span class="comment">// 任意枚举除外的单例模式</span></span><br><span class="line">        Singleton s1 = Singleton.getInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将s写入本地某个路径</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(path);</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">        oos.writeObject(s1);</span><br><span class="line">        oos.close();</span><br><span class="line">        fos.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从本地某个路径读取写入的对象</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(path));</span><br><span class="line">        Singleton s2 = (Singleton) ois.readObject();</span><br><span class="line">        System.out.println(s1); <span class="comment">// 我的s1输出：singleton.Singleton@14ae5a5</span></span><br><span class="line">        System.out.println(s2); <span class="comment">// 我的s2输出：singleton.Singleton@6d03e736</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="反序列化破解-2"><p>下面是来自ObjectInputStream类的注释</p><blockquote><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">* If the deserialized object defines a readResolve method</span><br><span class="line">* and the invocation of that method returns an array, then readUnshared</span><br><span class="line">* returns a shallow clone of that array; this guarantees that the returned</span><br><span class="line">* array object is unique and cannot be obtained a second time from an</span><br><span class="line">* invocation of readObject or readUnshared on the ObjectInputStream,</span><br><span class="line">* even if the underlying data stream has been manipulated.</span><br></pre></td></tr></tbody></table></figure></blockquote><p>大致意思是如果被反序列化的对象定义了readResolve方法,那么ObjectInputStream的readUnshared将返回一个对象的浅克隆，这保证了对象是唯一的并且不能通过调用ObjectInputStream的方法进行二次获得。</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ObjectStreamException;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>{</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//反序列化定义该方法，则不需要创建新对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>{</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>再次调用DeserializeSingleton打印结果</p><p><img src="/mysource/image-20201027184110777.png" alt="image-20201027184110777"></p><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>首先要明白一点，只有<strong>枚举</strong>可以防止反射。</p><div class="tabs" id="反序列化破解"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#反序列化破解-1">反射破解单例</button></li><li class="tab"><button type="button" data-href="#反序列化破解-2">枚举防止反射</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="反序列化破解-1"><p>Singleton.java</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>{</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>ReflectSingleton.java</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectSingleton</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>{</span><br><span class="line">        Singleton s1=Singleton.getInstance();</span><br><span class="line">        Singleton s2=Singleton.getInstance();</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">        System.out.println(<span class="string">"=============反射破解单例==============="</span>);</span><br><span class="line">        <span class="comment">// Class&lt;?&gt; clazz = Class.forName("singleton.Singleton"); //全路径名：包名.类名</span></span><br><span class="line">        Class&lt;?&gt; clazz = s1.getClass();</span><br><span class="line">        Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor(<span class="keyword">null</span>);</span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Singleton s3 = (Singleton) constructor.newInstance(<span class="keyword">null</span>);</span><br><span class="line">        System.out.println(s3);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>输出结果：</p><p><img src="/mysource/image-20201027190137930.png" alt="image-20201027190137930"></p><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="反序列化破解-2"><p>枚举防止反射的原理分析</p><p>首先从ReflectSingleton看出，生成新的对象关键在于constructor.newInstance(null)，下面是Constructor.newInstance()方法代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(Object ... initargs)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InstantiationException, IllegalAccessException,</span></span><br><span class="line"><span class="function">           IllegalArgumentException, InvocationTargetException</span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (!override) {</span><br><span class="line">        <span class="keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {</span><br><span class="line">            Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">            checkAccess(caller, clazz, <span class="keyword">null</span>, modifiers);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">     <span class="comment">// 取得类修饰符和Modifier.ENUM(0x00004000)做位与运算,如果结果不等于0，就抛出IllegalArgumentException</span></span><br><span class="line">    <span class="keyword">if</span> ((clazz.getModifiers() &amp; Modifier.ENUM) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot reflectively create enum objects"</span>);</span><br><span class="line">    ConstructorAccessor ca = constructorAccessor;   <span class="comment">// read volatile</span></span><br><span class="line">    <span class="keyword">if</span> (ca == <span class="keyword">null</span>) {</span><br><span class="line">        ca = acquireConstructorAccessor();</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@SuppressWarnings("unchecked")</span></span><br><span class="line">    T inst = (T) ca.newInstance(initargs);</span><br><span class="line">    <span class="keyword">return</span> inst;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>那么枚举类的修饰符是什么呢？</p><p>创建枚举类</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>{</span><br><span class="line">    INSTANCE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>获取类修饰符的值并打印</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumModifier</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> mod = Singleton.class.getModifiers();</span><br><span class="line">        String modifiers = Modifier.toString(mod);</span><br><span class="line">        System.out.println(mod); <span class="comment">//打印结果16401</span></span><br><span class="line">        System.out.println(modifiers); <span class="comment">//打印结果public final</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>为了验证结果，使用javac 编译Singleton.java，再通过javap反编译Singleton.class（<font color="red">这个反编译结果并非最终结果，详细原因稍后再说</font>）</p><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> D:\idea_workspace\design_pattern\src\singleton&gt; javac .\Singleton.java</span><br><span class="line"><span class="built_in">PS</span> D:\idea_workspace\design_pattern\src\singleton&gt; javap .\Singleton.class</span><br><span class="line">Compiled from <span class="string">"Singleton.java"</span></span><br><span class="line">public final <span class="class"><span class="keyword">class</span> <span class="title">singleton</span>.<span class="title">Singleton</span> <span class="title">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Enum</span>&lt;<span class="title">singleton</span>.<span class="title">Singleton</span>&gt;</span> {</span><br><span class="line">  public <span class="keyword">static</span> final singleton.Singleton INSTANCE;</span><br><span class="line">  public <span class="keyword">static</span> singleton.Singleton<span class="function">[] <span class="title">values</span></span>();</span><br><span class="line">  public <span class="keyword">static</span> singleton.Singleton valueOf(java.lang.String);</span><br><span class="line">  <span class="keyword">static</span> {};</span><br><span class="line">}</span><br><span class="line"><span class="built_in">PS</span> D:\idea_workspace\design_pattern\src\singleton&gt;</span><br></pre></td></tr></tbody></table></figure><p>可以看到输出是正确的，那么回到最初，clazz.getModifiers() &amp; Modifier.ENUM的结果是大于0的，当我们使用反射去创建对象的时候，理应会抛出IllegalArgumentException，让我们实验下我们的猜想</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectSingleton</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>{</span><br><span class="line">        Singleton s1=Singleton.INSTANCE;</span><br><span class="line">        Singleton s2=Singleton.INSTANCE;</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">        System.out.println(<span class="string">"=============反射破解单例==============="</span>);</span><br><span class="line">        <span class="comment">// Class&lt;?&gt; clazz = Class.forName("singleton.Singleton"); //全路径名：包名.类名</span></span><br><span class="line">        Class&lt;?&gt; clazz = s1.getClass();</span><br><span class="line">        Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor(<span class="keyword">null</span>);</span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Singleton s3 = (Singleton) constructor.newInstance(<span class="keyword">null</span>);</span><br><span class="line">        System.out.println(s3);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="/mysource/image-20201027202534412.png" alt="image-20201027202534412"></p><p>为什么执行结果和我们的预期不一致呢？</p><p>这就回到了我提到的javap反编译结果并非最终结果(我还使用JD-GUI查看，结果基本一致)，那么最终反编译结果是什么样呢？</p><p>这里要介绍一款很老的反编译工具：<a href="https://varaneckas.com/jad/">jad</a></p><p>将jad.exe放在Singleton.class的同级目录下，反编译Singleton.class</p><figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">D:\idea_workspace\design_pattern\src\singleton&gt;jad <span class="literal">-p</span> Singleton.class</span><br><span class="line">// Decompiled by Jad v1.<span class="number">5.8</span>g. Copyright <span class="number">2001</span> Pavel Kouznetsov.</span><br><span class="line">// Jad home page: http://www.kpdus.com/jad.html</span><br><span class="line">// Decompiler options: packimports(<span class="number">3</span>)</span><br><span class="line">// Source File Name:   Singleton.java</span><br><span class="line"></span><br><span class="line">package singleton;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public final <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="title">extends</span> <span class="title">Enum</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> Singleton<span class="function">[] <span class="title">values</span></span>()</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> (Singleton[])<span class="variable">$VALUES</span>.clone();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> Singleton valueOf(String s)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> (Singleton)Enum.valueOf(singleton/Singleton, s);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    private Singleton(String s, int i)</span><br><span class="line">    {</span><br><span class="line">        super(s, i);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> final Singleton INSTANCE;</span><br><span class="line">    private <span class="keyword">static</span> final Singleton <span class="variable">$VALUES</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    {</span><br><span class="line">        INSTANCE = new Singleton(<span class="string">"INSTANCE"</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="variable">$VALUES</span> = (new Singleton[] {</span><br><span class="line">            INSTANCE</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看到jad反编译的结果里枚举类的构造函数是private Singleton(String s, int i)，那么让我们改造ReflectSingleton.java并打印结果</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectSingleton</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>{</span><br><span class="line">        Singleton s1=Singleton.INSTANCE;</span><br><span class="line">        Singleton s2=Singleton.INSTANCE;</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">        System.out.println(<span class="string">"=============反射破解单例==============="</span>);</span><br><span class="line">        <span class="comment">// Class&lt;?&gt; clazz = Class.forName("singleton.Singleton"); //全路径名：包名.类名</span></span><br><span class="line">        Class&lt;?&gt; clazz = s1.getClass();</span><br><span class="line">        Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Singleton s3 = (Singleton) constructor.newInstance(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">        System.out.println(s3);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="/mysource/image-20201027204837678.png" alt="image-20201027204837678"></p><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实用网站</title>
      <link href="posts/d834b91a/"/>
      <url>posts/d834b91a/</url>
      
        <content type="html"><![CDATA[<p>免费图床: <a href="https://sm.ms/">https://sm.ms/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring系列学习</title>
      <link href="posts/982dfb85/"/>
      <url>posts/982dfb85/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-系列教程"><a href="#Spring-系列教程" class="headerlink" title="Spring 系列教程"></a>Spring 系列教程</h2><p>该仓库为个人博客<a href="https://mrbird.cc/">https://mrbird.cc</a>中Spring系列源码，包含Spring Boot、Spring Boot &amp; Shiro、Spring Cloud，Spring Boot &amp; Spring Security &amp; Spring Security OAuth2，仓库地址为<a href="https://github.com/wuyouzhuguli/SpringAll">https://github.com/wuyouzhuguli/SpringAll</a></p><h3 id="Spring-Boot教程"><a href="#Spring-Boot教程" class="headerlink" title="Spring Boot教程"></a>Spring Boot教程</h3><ol><li><a href="https://mrbird.cc/%E5%BC%80%E5%90%AFSpring-Boot.html">开启Spring Boot</a></li><li><a href="https://mrbird.cc/Spring-Boot%20basic%20config.html">Spring Boot基础配置</a></li><li><a href="https://mrbird.cc/Spring-Boot%20Mybatis.html">Spring Boot中使用MyBatis</a></li><li><a href="https://mrbird.cc/Spring-Boot%20JdbcTemplate.html">Spring Boot中使用JdbcTemplate</a></li><li><a href="https://mrbird.cc/Spring-Boot-MyBatis%20Druid.html">Spring Boot MyBatis配置Druid多数据源</a></li><li><a href="https://mrbird.cc/Spring-Boot-JdbcTemplate%20Druid.html">Spring Boot JdbcTemplate配置Druid多数据源</a></li><li><a href="https://mrbird.cc/Spring-Boot-AOP%20log.html">Spring Boot AOP记录用户操作日志</a></li><li><a href="https://mrbird.cc/Spring-Boot%E4%BD%BF%E7%94%A8thymeleaf.html">Spring Boot中使用thymeleaf</a></li><li><a href="https://mrbird.cc/Spring-Boot%20cache.html">Spring Boot中使用Redis缓存数据</a></li><li><a href="https://mrbird.cc/Spring-Boot%20cache.html">Spring Boot中使用Ehcache缓存数据</a></li><li><a href="https://mrbird.cc/Spring-Boot%20JSON.html">Spring Boot中的JSON技术</a></li><li><a href="https://mrbird.cc/Spring-Boot%20TESTing.html">Spring Boot中编写单元测试</a></li><li><a href="https://mrbird.cc/Spring-Boot-Swagger2-RESTful-API.html">Spring Boot整合Swagger2构建RESTful API</a></li><li><a href="https://mrbird.cc/Acutator-Spring-Boot.html">使用Actuator监控Spring Boot应用</a></li><li><a href="https://mrbird.cc/Spring-Boot-Email.html">使用Spring Boot发送邮件</a></li><li><a href="https://mrbird.cc/Spring-Boot-Admin.html">使用Spring Boot Admin监控服务</a></li><li><a href="https://mrbird.cc/Spring-Boot-Devtools.html">Spring Boot Devtools热部署</a></li><li><a href="https://mrbird.cc/Spring-Boot-logback.html">Spring Boot logback日志配置</a></li><li><a href="https://mrbird.cc/Spring-Boot%20war.html">Spring Boot项目打包成war包</a></li><li><a href="https://mrbird.cc/Linux%20Spring-Boot-jar.html">Linux下部署Spring Boot jar</a></li><li><a href="https://mrbird.cc/Jsoup%20XSS.html">Spring Boot中使用Jsoup防御XSS攻击</a></li><li><a href="https://mrbird.cc/Spring-Boot-Exception.html">Spring Boot异常处理</a></li><li><a href="https://mrbird.cc/Spring-Boot-Filter-Interceptor.html">Spring Boot中使用过滤器和拦截器</a></li><li><a href="https://mrbird.cc/MyBatis%20common%20Mapper%20PageHelper.html">Spring Boot整合MyBatis通用Mapper和PageHelper</a></li><li><a href="https://mrbird.cc/deepin-springboot-autoconfig.html">深入学习Spring Boot自动装配</a></li><li><a href="https://mrbird.cc/deepin-springboot-application.html">深入学习Spring Boot中的SpringApplication</a></li><li><a href="https://mrbird.cc/Spring-Boot-Hibernate-Validator-Params-Check.html">Spring Boot配合Hibernate Validator参数校验</a></li><li><a href="https://mrbird.cc/Spring-Boot-Diy-Resolver.html">自定义Spring Boot 内容协商</a></li><li><a href="https://mrbird.cc/Spring-Boot-Deal-CORS.html">Spring Boot 中处理跨域</a></li><li><a href="https://mrbird.cc/Spring-Boot-Async.html">Spring Boot 中的异步调用</a></li><li><a href="https://mrbird.cc/Spring-Boot-Kafka.html">Spring Boot 整合Kafka</a></li><li><a href="https://mrbird.cc/Spring-Boot-Mongo-DB-CRUD.html">Spring Boot整合Mongo DB</a></li><li><a href="https://mrbird.cc/Spring-Boot-2-0-WebFlux.html">Spring Boot 2.0 WebFlux编程</a></li><li><a href="https://mrbird.cc/Spring-Boot-WebFlux-CRUD.html">Spring Boot WebFlux增删改查样例</a></li><li><a href="https://mrbird.cc/Spring-Boot%E6%95%B4%E5%90%88WebSocket.html">Spring Boot整合WebSocket</a></li></ol><h3 id="Spring-Boot-amp-Shiro教程"><a href="#Spring-Boot-amp-Shiro教程" class="headerlink" title="Spring Boot &amp; Shiro教程"></a>Spring Boot &amp; Shiro教程</h3><ol><li><a href="https://mrbird.cc/Spring-Boot-shiro%20Authentication.html">Spring Boot Shiro用户认证</a></li><li><a href="https://mrbird.cc/Spring-Boot-Shiro%20Remember-Me.html">Spring Boot Shiro Remember Me</a></li><li><a href="https://mrbird.cc/Spring-Boot-Shiro%20Authorization.html">Spring Boot Shiro权限控制</a></li><li><a href="https://mrbird.cc/Spring-Boot-Shiro%20cache.html">Spring Boot Shiro Redis</a></li><li><a href="https://mrbird.cc/Spring-Boot-Shiro%20cache.html">Spring Boot Shiro Ehcache</a></li><li><a href="https://mrbird.cc/Spring-Boot-Themeleaf%20Shiro%20tag.html">Spring Boot Thymeleaf中使用Shiro标签</a></li><li><a href="https://mrbird.cc/Spring-Boot-Shiro%20session.html">Spring Boot Shiro在线会话管理</a></li><li><a href="https://github.com/wuyouzhuguli/SpringAll/tree/master/62.Spring-Boot-Shiro-JWT">Spring Boot Shiro整合JWT</a></li></ol><h3 id="Spring-Boot-amp-Security教程"><a href="#Spring-Boot-amp-Security教程" class="headerlink" title="Spring Boot &amp; Security教程"></a>Spring Boot &amp; Security教程</h3><ol><li><a href="https://mrbird.cc/Spring-Boot&amp;Spring-Security.html">Spring Boot中开启Spring Security</a></li><li><a href="https://mrbird.cc/Spring-Security-Authentication.html">Spring Security自定义用户认证</a></li><li><a href="https://mrbird.cc/Spring-Security-ValidateCode.html">Spring Security添加图形验证码</a></li><li><a href="https://mrbird.cc/Spring-Security-RememberMe.html">Spring Security添加记住我功能</a></li><li><a href="https://mrbird.cc/Spring-Security-SmsCode.html">Spring Security短信验证码登录</a></li><li><a href="https://mrbird.cc/Spring-Security-Session-Manage.html">Spring Security Session管理</a></li><li><a href="https://mrbird.cc/Spring-Security-logout.html">Spring Security退出登录</a></li><li><a href="https://mrbird.cc/Spring-Security-Permission.html">Spring Security权限控制</a></li><li><a href="https://mrbird.cc/Spring-Security-OAuth2-Guide.html">Spring Security OAuth2入门</a></li><li><a href="https://mrbird.cc/Spring-Security-OAuth2-Customize.html">Spring Security OAuth2自定义Token获取方式</a></li><li><a href="https://mrbird.cc/Spring-Security-OAuth2-Token-Config.html">Spring Security OAuth2自定义令牌配置</a></li><li><a href="https://mrbird.cc/Spring-Security-OAuth2-SSO.html">Spring Security OAuth2单点登录</a></li></ol><h3 id="Spring-Cloud教程"><a href="#Spring-Cloud教程" class="headerlink" title="Spring Cloud教程"></a>Spring Cloud教程</h3><ol><li><a href="https://mrbird.cc/Spring-Cloud%20and%20MicroService.html">初识Spring Cloud与微服务</a></li><li><a href="https://mrbird.cc/Spring-Cloud-Eureka.html">Spring Cloud Eureka服务治理</a></li><li><a href="https://mrbird.cc/Spring-Cloud-Ribbon-LoadBalance.html">Spring Cloud Ribbon客户端负载均衡</a></li><li><a href="https://mrbird.cc/Spring-Cloud-Hystrix-Circuit-Breaker.html">Spring Cloud Hystrix服务容错</a></li><li><a href="https://mrbird.cc/Spring-Cloud-Hystrix-Dashboard.html">Spring Cloud Hystrix Dashboard仪表盘</a></li><li><a href="https://mrbird.cc/Spring-Cloud-Hystrix-Dashboard.html">Spring Cloud Hystrix Dashboard仪表盘 &amp; RabbitMQ</a></li><li><a href="https://mrbird.cc/Spring-Cloud-Feign.html">Spring Cloud Feign 声明式服务调用</a></li><li><a href="https://mrbird.cc/Spring-Cloud-Zuul-Router.html">Spring Cloud Zuul服务网关</a></li><li><a href="https://mrbird.cc/Spring-Cloud-Config.html">Spring Cloud Config统一配置管理</a></li><li><a href="https://mrbird.cc/Spring-Cloud-Bus.html">使用Spring Cloud Bus刷新配置</a></li><li><a href="https://mrbird.cc/Spring-Cloud-sleuth.html">使用Spring Cloud Sleuth跟踪微服务</a></li><li><a href="https://mrbird.cc/Spring-Cloud-Consul.html">Spring Cloud Consul服务治理</a></li><li><a href="https://mrbird.cc/Spring-Cloud-Alibaba-Nacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83.html">Spring Cloud Alibaba Nacos注册中心</a></li><li><a href="https://mrbird.cc/Spring-Cloud-Alibaba-Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83.html">Spring Cloud Alibaba Nacos配置中心</a></li><li><a href="https://mrbird.cc/Sentinel%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%AF%A6%E8%A7%A3.html">Spring Cloud Alibaba Sentinel控制台详解</a></li><li><a href="https://mrbird.cc/Spring-Cloud-Alibaba-Sentinel-SentinelResource.html">Spring Cloud Alibaba Sentinel @SentinelResource</a></li></ol><h3 id="Spring-Boot-amp-amp-Dubbo教程"><a href="#Spring-Boot-amp-amp-Dubbo教程" class="headerlink" title="Spring Boot &amp;&amp; Dubbo教程"></a>Spring Boot &amp;&amp; Dubbo教程</h3><ol><li><a href="https://mrbird.cc/Spring-Boot-Dubbo-Zookeeper.html">Spring Boot整合Dubbo&amp;Zookeeper</a></li><li><a href="https://mrbird.cc/dubbo-mointor.html">监控Dubbo服务</a></li><li><a href="https://mrbird.cc/Dubbo-High-Availability.html">Dubbo的高可用</a></li></ol><h3 id="Spring-Boot-amp-amp-Spring-Batch教程"><a href="#Spring-Boot-amp-amp-Spring-Batch教程" class="headerlink" title="Spring Boot &amp;&amp; Spring Batch教程"></a>Spring Boot &amp;&amp; Spring Batch教程</h3><ol><li><a href="https://mrbird.cc/Spring-Batch%E5%85%A5%E9%97%A8.html">Spring Batch入门</a></li><li><a href="https://mrbird.cc/Spring-Batch%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE.html">Spring Batch读取数据</a></li><li><a href="https://mrbird.cc/Spring-Batch%E8%BE%93%E5%87%BA%E6%95%B0%E6%8D%AE.html">Spring Batch输出数据</a></li><li><a href="https://mrbird.cc/Spring-Batch%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE.html">Spring Batch处理数据</a></li><li><a href="https://mrbird.cc/Spring-Batch%E7%9B%91%E5%90%AC%E5%99%A8.html">Spring Batch监听器</a></li><li><a href="https://mrbird.cc/Spring-Batch%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html">Spring Batch异常处理</a></li><li><a href="https://mrbird.cc/Spring-Batch%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6.html">Spring Batch任务调度</a></li></ol><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><ol><li><a href="https://mrbird.cc/Spring-Bean-Regist.html">深入学习Spring组件注册</a></li><li><a href="https://mrbird.cc/Spring-Bean-Lifecycle.html">深入学习Spring Bean生命周期</a></li></ol><p>持续更新中…</p>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一个站点</title>
      <link href="posts/99e880cf/"/>
      <url>posts/99e880cf/</url>
      
        <content type="html"><![CDATA[<h1 id="本站说明"><a href="#本站说明" class="headerlink" title="本站说明"></a>本站说明</h1><p>本博客使用Vercel托管hexo静态页面，使用腾讯云域名注册，主题使用<a href="https://github.com/jerryc127/hexo-theme-butterfly">hexo-theme-butterfly</a>，配置步骤参考<a href="https://demo.jerryc.me/">https://demo.jerryc.me/</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
